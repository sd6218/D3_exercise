{ ---------------------------------------start------------------------------------------ }

: clear-stack depth 1 + 1 do i drop . loop ;   { depth 1 + is the number of values in stack +1, since the loop take n-1 as  the end }
                                               { start with 1, operate the drop for the index appointed value in stack, drop from the top }


{ Qs  a }

: square_print cr
	101 1 do i dup * . loop ;                 { word that print the square of 1-100 } 

{ Qs  b }


variable array-size
variable array-dim




: cal_size                                                  { input array, take n }
	dup
	dup array-dim !
	dup * array-size ! 
	drop 
	 
	;
	
create array array-size @ allocate drop




: show 	
	cr                                                 { start from the next line }
	array-size @ 0 do array i + c@   5 .r                        { print values with 5 spaces between elements  }
	i 1 +                                                   { set up the conditon to return to next line } 
	array-dim @ mod 0=                                            { jumping point }
	if cr                                                   { at every 10th value jump }
	then loop ;


{---------------------------------------adding random number to array-------------------------------------  }

CREATE SEED  123475689 ,

: Rnd ( n -- rnd )   { Returns single random number less than n }
   SEED              { Minimal version of SwiftForth Rnd.f      }
   DUP >R            { Algorithm Rick VanNorman  rvn@forth.com  }
   @ 127773 /MOD 
   2836 * SWAP 16807 * 
   2DUP > IF - 
   ELSE - 2147483647 +  
   THEN  DUP R> !
   SWAP MOD ;
   
: random_! 
	
	array-size @ 0 do 9 Rnd array i + c! loop ;
  
  
 { # cal_size and show and random_@ and show, follow this order                }
  
  
{ -------------------------------------find number of elements in the matrix-------------------------------- }

create  count_ar  4 9 *   allocate  drop drop

: reset_cou 9 0 do 0 count_ar  i + ! loop ;

: show_cou
	
	cr
	." number "
	cr
	9 0 do i  7 .r  loop   
	cr
	." counts "
	cr
	9 0 do count_ar i + @  7 .r loop ;

: count                                           { this should retrun 25 0s }
	cr 
	array-size @ 0 
	do  10 0 do
	array j + c@ 
    i =
	if count_ar i + @
	then
	loop loop ;
	
: c                                                 {  have problem here ??????????????????? trying to used counter }
	cr 
	array-size @ 0 
	do  
	array i + c@ 
	case                                   
		1 of 1 = drop count_ar 1 + @ 1 + endof 
	endcase
	loop ;

5 cal_size
random_!
reset_cou
